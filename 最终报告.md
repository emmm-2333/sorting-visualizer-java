


数据结构与算法课程设计


排序算法性能比较与动画演示系统



班       级：    网络244
学 生 姓 名：    舒钟渭
学       号：    2024083418
完 成 日 期：    12.27



大连民族大学

1 问题描述
排序算法是数据结构与算法课程的核心内容之一。不同排序算法在不同数据规模与数据分布下具有不同的效率特征，仅从理论复杂度往往难以直观感受到“比较/交换/写回”等关键步骤对运行过程的影响。本课程设计实现一个桌面端“排序算法性能比较与动画演示系统”。
该系统实现以下功能：
1）使用数组存储待排序数据，支持生成数据、自定义输入及文件读取（如 .txt/.csv）。
2）支持多种排序算法（如快速排序、归并排序、堆排序、计数排序、基数排序、桶排序等），并保证排序正确性。
3）逐步展示排序过程中的关键操作（比较、交换、写回），通过动画演示帮助理解算法原理；支持“上一步/下一步/暂停/继续”，并在界面中回显“本步做了什么操作”。
4）对不同算法在同一数据集上进行性能对比，展示耗时、内存占用估算、稳定性、复杂度等指标，并以图表与表格输出；图表柱子支持悬停提示（ms/MB）。
5）提供友好界面，支持算法选择、数据输入/选择、结果展示，并支持动画速度调节、退出排序（恢复到排序前数据）等交互控制。
最终系统将是一个可视化排序算法演示平台，能够直观展示算法执行过程，并支持性能比较分析。
2 需求分析
系统的基本功能：
1）数据准备：支持三种数据来源。
（a）生成数据：支持“随机数据/有序数据/逆序数据/部分有序”四种类型，数据量在界面输入框中给出（代码中生成时将数据量限制在5~500；默认数据量为30）。
（b）自定义输入：在“自定义数据”文本框输入整数序列，支持空格/逗号/分号/制表符/换行等分隔符。
（c）文件读取：通过文件选择器加载.txt/.csv文件，读取内容后按同一解析规则转为数组。
2）动画排序：用户选择算法后点击“开始排序”，系统采用两阶段实现动画演示：
（a）录制阶段：在后台线程执行排序算法，但不直接驱动UI动画；系统把排序中的关键事件（比较/交换/写回）记录为可回放的操作序列。
（b）回放阶段：在UI线程中按一定延时逐步回放操作序列，驱动柱状图更新；支持速度调节，暂停/继续，上一步/下一步，操作回显，步骤统计，排序完成态。
3）性能比较：点击"性能比较"后，系统将对多种排序算法在同一数据集上进行基准测试。测试过程采用纯排序模式，禁用动画回调与回放机制，以消除可视化开销，确保算法耗时的准确性。测试结果包括各算法的实际执行时间、内存占用估算、算法复杂度与稳定性等元数据。结果以时间对比柱状图、内存对比柱状图（估算值）和详细数据表三种形式展示便于用户直观比较不同算法的性能差异。
输入形式：
1）生成数据：在界面输入“数据量”，选择“数据类型”，点击“生成数据”。
2）自定义输入：在“自定义数据”文本框输入一串整数（例如：3,1,4,1,5），点击“显示数据”。
3）文件读取：点击“读取文件”，选择.txt/.csv文件。
输出形式：
1）动画演示输出：中间区域以柱状图形式显示数组；比较/交换/写回过程以不同颜色高亮显示；支持步骤计数、操作回显与次数统计；完成态统一绿色。
2）性能比较输出：时间对比柱状图、内存对比柱状图（估算）、详细数据表（复杂度/稳定性等），并支持图表悬停提示。
测试数据要求：
1）生成数据：程序生成的数据为正整数序列（值域为1~size）。
2）自定义/文件输入：需为可解析的整数序列；为了保证可视化柱状图显示效果，建议使用非负整数。
3 概要设计
3.1 抽象数据类型
ADT  待排序数据（数组）
Data
以 `int[]` 表示待排序数据。
Operation
generateData
前置条件：用户已输入数据量、选择数据类型
输入：size、type
功能：生成随机/有序/逆序/部分有序数组
输出：int[]
后置条件：数组在界面中以柱状图显示
parseInputString
前置条件：用户已输入自定义字符串
输入：String input
功能：按多分隔符解析为整数数组
输出：int[]
后置条件：数组在界面中以柱状图显示
loadFromFile
前置条件：用户已选择文件
输入：File file
功能：读取文件内容并解析为整数数组
输出：int[]
后置条件：数组在界面中以柱状图显示
End ADT
ADT  排序步骤监听器（动画回调）
Data
无
Operation
onCompare
前置条件：排序正在进行
输入：index1, index2
功能：表示比较两个下标的元素
输出：无
后置条件：界面高亮比较位置
onSwap
前置条件：排序正在进行
输入：index1, index2
功能：表示交换两个下标的元素
输出：无
后置条件：界面更新数组并高亮交换位置
onSet
前置条件：排序正在进行
输入：index, value
功能：表示覆盖写回（赋值）操作
输出：无
后置条件：界面更新数组并高亮写回位置
End ADT
3.2 模块调用关系
应用入口层：SortingVisualizerApp：JavaFX应用入口，负责创建窗口、加载界面并显示。
控制层：MainController：主控制器，负责用户交互、输入校验、任务启动与视图切换。
服务层：StepRecordingService：步骤录制服务；在后台线程执行排序算法，并把关键事件记录为可回放操作序列。
PlaybackController：回放控制器；负责自动回放定时、上一步/下一步/暂停/继续等控制，并向控制层输出回放快照。
BenchmarkService：性能基准测试服务；批量运行算法，统计耗时与内存估算。
DataInputService：数据输入服务；解析自定义输入字符串与文件内容。
DataGenerator：数据生成器；生成随机/有序/逆序/部分有序数据。
核心层：AlgorithmRegistry：算法注册表；管理算法实例与元数据，提供算法查找与列表。
Sorter实现类：各具体排序算法实现。
数据模型层：AlgorithmInfo：算法元数据（复杂度、稳定性等）。
PerformanceMetrics：性能测试输出（耗时、内存估算、元数据等）。
视图层：VisualizerPane：可视化面板；负责绘制柱状图，支持高亮、标签、完成态统一绿色。
BenchmarkViewBuilder：性能比较结果视图构建；负责构建图表与表格，并为图表柱子提供悬停提示。
模块调用关系如下：



图3.1 模块调用关系
3.3 主程序流程



图3.2 主程序流程图
4 详细设计
（1）实现概要设计的数据类型：
1）基本类型
int：数组元素值、索引、数据规模等。
long：动画延迟（毫秒）、性能计时（纳秒）、内存估算（字节）。
boolean：暂停状态、是否显示标签、算法稳定性标记等。
double：部分算法计算中间量（例如桶排序的range），以及结果展示中的单位换算。
2）字符串类型（String）
String用于表示：算法名称、数据类型（随机/有序/逆序/部分有序）、提示文本等。
3）数组类型（int[]）
系统的“被排序数据”统一用int[]表示。为了避免排序过程直接破坏UI侧的数据引用：录制阶段对输入数组做拷贝；回放阶段维护一份工作数组用于apply/undo。
4）集合类型（List/Map 等）
List<String>：算法名称列表（用于下拉框）。
List<PerformanceMetrics>：性能比较输出结果集合。
Map<String,Sorter>、Map<String,AlgorithmInfo>：算法注册表中“名称→实例/元数据”的映射。
List<SortOperation>：排序步骤列表（录制输出）。
（2）主程序以及主要模块的算法描述：
①主界面控制器（MainController）



图4.1 MainController流程图
本模块作为系统的统一业务入口与状态中枢，承接并协调所有用户操作流程，包括生成数据、输入数据、开始排序、回放控制、退出排序以及性能比较等功能；同时集中维护与同步关键运行状态，例如当前数组、排序前数组快照、录制/回放进行状态以及统计信息展示开关等，确保界面与业务逻辑一致。为保证交互流畅与线程安全，录制过程与性能比较等耗时任务统一放入后台线程执行，而所有界面刷新与控件状态更新严格限定在UI线程中完成，从而避免卡顿与并发错误并提升整体稳定性。
②后台录制步骤服务（StepRecordingService）



图4.2后台录制步骤流程图
本模块用于在后台线程中执行用户选定的排序算法，并将排序过程从UI动画转变为可回放的操作序列。最终生成RecordedSort（初始数组+操作序列）供后续回放与可视化使用；同时对不适合演示的算法与数据规模组合进行预先限制，并在需要时给出提示，以保证演示效果与运行稳定性。
③自动回放控制器（PlaybackController）



图4.3自动回放流程图
本模块用于统一管理自动回放、暂停与播放延迟等播放状态，并将用户的暂停/继续/下一步/上一步/停止等操作抽象为对StepPlayer的一致控制；在自动回放模式下，模块按照设定的延迟周期定时触发“下一步”推进，从StepPlayer获取当前快照并发布到UI刷新展示，当回放到达末尾时自动停止并进入完成态（统一绿色），暂停则仅停止定时推进但保留当前游标与画面，停止/退出则终止推进并释放回放相关状态。
④ 性能比较服务（BenchmarkService）



图4.4性能比较流程图
本模块用于对多种排序算法在同一基准数据集上进行基准测试，统计耗时与内存占用增量估算，并输出PerformanceMetrics列表供结果视图绘制柱状图与表格；测试过程中不启用动画回调或回放机制，以避免UI开销对计时产生干扰。模块会预先按指定规模与数据类型生成测试数组，然后依次对各算法克隆输入、必要时触发垃圾回收以稳定内存测量，分别记录排序前后的时间与内存基线并计算差值，最终汇总生成性能报告交由UI进行可视化展示。
（3）其它模块的算法描述
1）数据输入服务（DataInputService）
功能：将用户输入字符串或文件内容解析为int[]。
核心逻辑：将用户输入的字符串或文件内容统一转换为标准格式，按分隔符切分为多个token，逐个解析为整数并构建数组，对非法输入或解析失败的情况抛出异常提示。整个过程实现了用户输入到程序可用数据的转换，确保数据格式的规范性和解析的健壮性。
2）可视化绘制（VisualizerPane）
功能：把数组绘制为柱状图，并根据“当前步”高亮相关柱子；支持显示数值标签；排序完成时统一绿色。。
核心逻辑：将输入的整数数组归一化到画布尺寸，依次绘制每个元素对应的矩形柱，在排序过程中若属于当前操作涉及的索引，使用对应高亮色，支持显示数值标签。整个过程实现了数据到视觉元素的实时映射，通过JavaFX的Canvas绘图机制保证渲染效率。
3）回放控制器（PlaybackController）
功能：维护排序过程的状态，支持前进/后退操作，并产出每一步的快照信息。
核心逻辑：内部维护工作数组和游标（当前回放进度），加载时用初始数组初始化工作数组并将游标置0；执行"下一步"时若游标未到末尾则应用当前操作并游标+1，否则保持不变；执行"上一步"时若游标不为0则游标-1并撤销对应操作，否则保持不变；每次操作后产出快照信息（当前数组、涉及索引、操作类型/描述、当前步/总步）。整个过程实现了排序过程的精确回放控制，通过操作序列的逆运算实现撤销功能，边界条件处理确保游标不会越界，为UI层提供完整的回放状态信息。
5 编码与调试分析
(1)编码与调试过程中遇到的问题及解决办法：
【问题一】实时动画模式无法可靠支持“上一步”
现象：排序过程向前推进后，无法撤销已经对数组造成的修改。
解决办法：升级为“录制-回放/撤销”模型：录制阶段把关键步骤抽象为可执行/可撤销的操作；回放阶段由游标控制前进/后退，实现稳定的上一步/下一步。
【问题二】演示型低效算法在较大规模下导致异常（例如猴子排序）
现象：规模稍大就会出现步骤爆炸，导致耗时过长甚至内存耗尽。
解决办法：对该类算法加入保护性限制：当规模超过安全阈值时直接阻止执行，并提示用户降低规模。
【问题三】性能比较结果展示可读性不足
现象：纯图表不易读出精确数值。
解决办法：结果视图构建抽离为独立模块；图表柱子悬停显示提示信息（耗时ms、内存MB）；同时提供表格明细用于精确对比。
【问题四】性能比较结果波动大、不同次运行差距明显
现象：同一算法多次运行耗时差异较大，结果不稳定。
解决办法：采用多次运行取平均值或中位数；在界中明确说明内存为估算值，仅供参考；建议使用专业基准测试框架（如JMH）作为扩展方向，提高测试精度。
6 使用说明
1）运行环境与启动
本程序基于Java17与JavaFX17，使用Maven构建。运行前需安装JDK17，Maven。启动方式为在项目根目录执行mvn clean Java fx:run，启动后将显示主窗口"排序算法性能比较与动画演示系统"。
2）本操作流程
用户可通过"数据规模"和"数据类型"下拉框生成指定数据（随机/有序/逆序/部分有序），上限为500个元素。选择算法后点击"开始排序"启动动画演示，比较、交换操作会以不同颜色高亮显示，速度滑块可动态调整动画延迟（1ms~1000ms）。排序过程中可随时暂停/继续，或点击"退出排序"终止任务并恢复排序前数据。
性能比较功能会批量测试多个算法，完成后展示耗时、内存占用及详细数据表。用户也可通过自定义输入或文件加载数据，支持多种分隔符（空格、逗号、分号等），输入异常会提示错误。
3）显示设置与注意事项
"显示数值"选项控制柱状图上的标签显示，不影响排序逻辑。建议使用非负整数数据，当数据规模较大或速度过快时可能出现卡顿，可适当调整参数优化体验。
7 测试结果
（1）程序主页面
图7.1程序主页面

（2）选择排序算法

图7.2选择不同的排序算法
可以选择的算法包括;冒泡排序；快速排序；归并排序；堆排序；插入排序；希尔排序；选择排序；计数排序；桶排序；基数排序；猴子排序；睡眠排序；珠排序
（3）演示排序动画
图7.3正在快速排序

（4）生成逆序/有序数据
图7.4生成逆序/有序数据
（5）性能比较
图7.5.1性能摘要
图7.5.2算法耗时对比
图7.5.3算法详细数据
（6）读取自定义数据
图7.6.1读取自定义数据文件
图7.6.1读取输入的自定义数据
（6）步进/回放控制测试：
图7.6.1查看上一步
图7.6.2继续下一步
8 团队合作
8.1 讨论问题
问题1：在进行算法性能测试时，发现同一算法在相同数据规模下的多次测试结果存在一定波动，特别是在数据量较小时波动更为明显。这种现象影响了性能比较的准确性和可靠性。
问题1解决办法：通过分析讨论得知，性能测试结果波动主要源于多个因素。首先是系统资源竞争，其他进程占用CPU和内存资源会影响测试结果的准确性。其次是Java虚拟机的即时编译优化机制，初次运行时代码未被充分优化，导致执行效率不稳定。此外垃圾回收过程可能在测试期间发生，对执行时间产生干扰。最后当测试数据规模过小时，微小的时间差异会被放大显示，造成明显的波动。
为了解决这些问题，采用了多种优化措施。首先是进行多轮测试并取平均值，以此减少偶然误差的影响。其次在正式测试前增加预热环节，让JVM有充足时间对代码进行优化。同时在测试时尽量减少其他程序运行，降低系统负载对测试结果的干扰。最后通过增加测试数据规模，使测试结果更具代表性和稳定性。
8.2 团队成员
舒钟渭、温雨桐、刘之俊
8.3 自学知识点

1. 异常处理
在排序算法执行和系统运行过程中，完善的异常处理机制是确保系统稳定性和用户体验的关键要素。
1.1 捕获和处理排序过程中的简单异常，避免程序崩溃
系统在执行排序任务时可能遇到各种异常情况，如算法实现错误、数据访问越界等。为了确保系统的稳定性，采用了分层异常处理机制。在核心排序服务中捕获可能发生的异常，防止其向上传播导致整个应用程序崩溃。通过合理的异常捕获和处理，系统能够在遇到问题时优雅地终止当前操作，并保持应用程序主体功能的正常运行。

1.2 提供友好的错误提示，如格式错误、算法不存在等
为了让用户更好地理解和解决问题，系统不仅捕获异常，还提供清晰友好的错误提示信息。当用户输入的数据格式不正确时，系统会给出具体的错误原因和修正建议。当选择的算法不存在或不可用时，会明确告知用户并提供可选的解决方案。这种用户友好的错误处理方式大大提升了系统的易用性和用户体验，使用户能够快速定位和解决问题，而不需要深入理解复杂的系统内部机制。
参 考 文 献
[1]Oracle. JavaFX官方文档[EB/OL]. <https://openjfx.io/javadoc/17/>, 2023.
[2]Maven Apache. Apache Maven Documentation[EB/OL]. <https://maven.apache.org/guides/>, 2023

[3]杨晓波，庞双双，张龙辉，等.冒泡排序可视化的设计与实现[J].软件，2013(9).

[4]魏莉.基于OpenGL的常用排序算法可视化系统设计与实现[J].安徽广播电视大学学报,2019(3).

