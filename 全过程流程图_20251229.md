# 排序算法可视化系统：全过程流程图（对齐当前代码实现）

日期：2025-12-29

> 本文基于当前仓库的实际代码与文档：
>
> - 
>
>   [SortingVisualizerApp.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/SortingVisualizerApp.java)
>
> - 
>
>   [MainLayout.fxml](https://tencent.yuanbao/src/main/resources/org/example/sortingvisualizer/view/MainLayout.fxml)
>
> - 
>
>   [MainController.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java)
>
> - 
>
>   [StepRecordingService.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/StepRecordingService.java)
>
> - 
>
>   [PlaybackController.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackController.java)
>
> - 
>
>   [StepPlayer.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/StepPlayer.java)
>
> - 
>
>   [VisualizerPane.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/VisualizerPane.java)
>
> - 
>
>   [BenchmarkService.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/BenchmarkService.java)
>
> - 
>
>   [BenchmarkViewBuilder.java](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/BenchmarkViewBuilder.java)
>
> - 
>
>   文档：[操作整理_新增步进与界面美化.md](https://tencent.yuanbao/操作整理_新增步进与界面美化.md)、[总报告*对齐现状版*20251226.md](https://tencent.yuanbao/总报告_对齐现状版_20251226.md)

------

## 1. 模块清单（含"做了什么"）

### 应用入口

- 

  [SortingVisualizerApp](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/SortingVisualizerApp.java)：加载 FXML、创建 Scene、注入 Apple 风格 CSS、展示 Stage。

### 视图布局（FXML）

- 

  [MainLayout.fxml](https://tencent.yuanbao/src/main/resources/org/example/sortingvisualizer/view/MainLayout.fxml)：定义顶部控件区（算法/数据/速度/按钮/统计/回显）与中心区域（放置 [VisualizerPane](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/VisualizerPane.java)或 benchmark TabPane）。

### 控制器（流程编排器）

- 

  [MainController](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java)：

  - 

    解析用户输入（规模/类型/自定义/文件）并更新可视化

  - 

    启动"录制任务"（后台）并在完成后启动"回放"（UI 定时）

  - 

    处理暂停/继续/上一步/下一步/退出排序

  - 

    发起"性能比较"后台任务并展示结果视图

### 算法注册与算法实现

- 

  [AlgorithmRegistry](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/algorithm/AlgorithmRegistry.java)：管理"中文算法名 → Sorter实例 / AlgorithmInfo元数据"的映射。

- 

  [Sorter](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/algorithm/Sorter.java)（接口）+ 具体实现：对数组排序；可选地通过 [SortStepListener](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/algorithm/SortStepListener.java)回调关键事件。

- 

  [SortStepListener](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/algorithm/SortStepListener.java)：三类事件：比较（COMPARE）/交换（SWAP）/写回（SET）。

### 步骤系统（录制→回放/撤销）

- 

  [StepRecordingService](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/StepRecordingService.java)：把算法回调转换为可回放/可撤销的 [SortOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SortOperation.java)列表，产出 [RecordedSort](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackSnapshot.java)。

- 

  [RecordedSort](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackSnapshot.java)：一次录制结果（algorithmName、initialArray、operations）。

- 

  [SortOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SortOperation.java)/[SortOperationType](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SortOperationType.java)：统一的 apply/undo + 描述文本。

- 

  [CompareOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/CompareOperation.java)/[SwapOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SwapOperation.java)/[SetOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SetOperation.java)：三类具体操作（支持撤销）。

- 

  [StepPlayer](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/StepPlayer.java)：维护工作数组与 cursor，提供 next/prev（前进与撤销），并产出"可回显的操作描述"。

### 回放控制

- 

  [PlaybackController](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackController.java)：封装 [StepPlayer](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/StepPlayer.java)+ JavaFX [PauseTransition](https://docs.oracle.com/javase/8/javafx/api/javafx/animation/PauseTransition.html)定时推进，向外发布 [PlaybackSnapshot](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackSnapshot.java)。

- 

  [PlaybackSnapshot](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackSnapshot.java)：一次更新快照（state/operation/cursor/size/hasPrev/hasNext/playing）。

### 可视化

- 

  [VisualizerPane](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/VisualizerPane.java)：绘制柱状图；支持 renderState 高亮与 renderFinalState 完成态统一绿色；可显示数值标签。

### 数据服务

- 

  [DataGenerator](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/util/DataGenerator.java)：生成随机/有序/逆序/部分有序数据。

- 

  [DataInputService](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/DataInputService.java)：解析自定义输入字符串与文件内容为 `int[]`。

### 性能比较

- 

  [BenchmarkService](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/BenchmarkService.java)：后台批量执行排序（不启用监听器），统计耗时与内存估算，输出 [PerformanceMetrics](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/model/PerformanceMetrics.java)列表。

- 

  [BenchmarkViewBuilder](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/BenchmarkViewBuilder.java)：把 metrics 渲染为 TabPane（摘要/时间/内存/表格），并给柱状图柱子安装 Tooltip。

------

## 2. 全局"用户视角"总流程图（从启动到结束）

```mermaid
flowchart TD
  S["启动程序"] --> A["<strong>SortingVisualizerApp</strong><br>加载 MainLayout.fxml"]
  A --> B["创建 Scene(1200x800) + 加载 apple.css"]
  B --> C["JavaFX 注入 MainController 并调用 initialize"]
  C --> D["<strong>MainController</strong><br>创建 VisualizerPane 放入 rootPane.center"]
  D --> E["初始化下拉框: AlgorithmRegistry 算法名列表 + 数据类型"]
  E --> F["初始化速度映射: slider -> delayMillis, 注入 PlaybackController"]
  F --> G["生成初始数组: DataGenerator"]
  G --> H["<strong>VisualizerPane</strong><br>绘制初始柱状图"]
  H --> W{"等待用户操作"}

  %% 数据准备
  W -->|"生成数据"| GD["<strong>DataGenerator</strong><br>解析规模 5..500 + 选择数据类型"]
  GD --> GD2["<strong>DataGenerator</strong><br>生成数组"]
  GD2 --> GD3["<strong>VisualizerPane</strong><br>setArray 重绘"]
  GD3 --> W

  W -->|"显示数据(自定义输入)"| SD["<strong>DataInputService</strong><br>parseInputString"]
  SD -->|失败| SD_ERR["弹窗提示: 解析失败"]
  SD -->|成功| SD_OK["<strong>VisualizerPane</strong><br>setArray 重绘"]
  SD_OK --> W

  W -->|读取文件| LD["文件选择器 -> <strong>DataInputService</strong><br>loadFromFile"]
  LD -->|失败| LD_ERR["弹窗提示: 读取失败/解析失败"]
  LD -->|成功| LD_OK["<strong>VisualizerPane</strong><br>setArray 重绘"]
  LD_OK --> W

  %% 动画排序
  W -->|开始排序| SS["保存 arrayBeforeSort 快照"]
  SS --> SS2["禁用输入控件; 显示'正在准备步骤...'"]
  SS2 --> SS3["后台 Task: <strong>StepRecordingService.record</strong>"]
  SS3 -->|失败/取消| SS_FAIL["恢复控件/状态; 若退出则还原快照"]
  SS3 -->|成功| SS_OK["<strong>PlaybackController</strong><br>load(recorded) + 设置回调"]
  SS_OK --> SS_OK2["启动自动回放: <strong>PlaybackController.start</strong>"]

  %% 回放操作
  SS_OK2 --> PB{"回放期间用户操作"}
  PB -->|暂停/继续| PB_PR["<strong>PlaybackController</strong><br>pause/start"]
  PB -->|上一步/下一步| PB_STEP["<strong>PlaybackController</strong><br>prev/next"]
  PB -->|退出排序| PB_EXIT["停止回放 + 取消录制(如有) + 恢复 arrayBeforeSort"]
  PB_PR --> PB
  PB_STEP --> PB
  PB_EXIT --> W

  %% 完成态
  SS_OK2 -->|到达末尾| FIN["<strong>VisualizerPane</strong><br>renderFinalState 统一绿色"]
  FIN --> W

  %% 性能比较
  W -->|性能比较| BM["<strong>MainController.onBenchmark</strong>"]
  BM --> BM2["后台 Task: <strong>BenchmarkService.createBenchmarkTask</strong>"]
  BM2 --> BM3["<strong>BenchmarkViewBuilder.buildResults</strong> -> TabPane"]
  BM3 --> BM4["rootPane.center = TabPane"]
  BM4 --> W
```

------

## 3. "开始排序"详细流程（录制→回放，含线程边界）

### 3.1 时序图：从点击"开始排序"到自动回放

```mermaid
sequenceDiagram
  participant U as 用户
  participant MC as MainController(UI线程)
  participant BG as 录制Task(后台线程)
  participant SR as StepRecordingService
  participant AR as AlgorithmRegistry
  participant S as Sorter(具体算法)
  participant PC as PlaybackController(UI线程)
  participant SP as StepPlayer
  participant VP as VisualizerPane

  U->>MC: 点击开始排序
  MC->>MC: 保存数组快照
  MC->>MC: 禁用控件
  MC->>MC: 清理旧回放回调定时器
  MC->>MC: 创建录制任务并启动线程

  MC->>BG: 启动线程
  BG->>AR: 获取算法实例
  AR-->>BG: 返回Sorter实例
  BG->>SR: 开始录制排序步骤

  Note over SR: initial/working/state 三份数组<br/>ops List 收集 SortOperation

  SR->>S: 执行排序算法
  loop 排序过程
    S-->>SR: 比较事件
    SR->>SR: 记录比较操作
    S-->>SR: 交换事件
    SR->>SR: 记录交换操作并同步状态
    S-->>SR: 写回事件
    SR->>SR: 记录设置操作
  end
  SR-->>BG: 返回录制结果

  BG-->>MC: 任务完成(回到UI线程)
  MC->>MC: 初始化步骤统计
  MC->>PC: 设置播放延迟
  MC->>PC: 设置更新回调
  MC->>PC: 设置完成回调
  MC->>PC: 加载录制结果
  PC->>SP: 创建步进播放器
  PC-->>MC: 发送准备开始快照
  MC->>VP: 渲染初始状态
  MC->>MC: 开始播放

  loop 自动回放循环
    PC->>SP: 前进一步
    SP-->>PC: 返回带描述的操作
    PC-->>MC: 发送更新快照
    MC->>VP: 渲染当前状态并高亮
    MC->>MC: 更新界面显示
  end

  PC-->>MC: 播放完成
  MC->>VP: 渲染最终状态为绿色
  MC->>MC: 恢复控件状态
```

### 3.2 录制阶段内部流程（StepRecordingService.record）

```mermaid
flowchart TD
  A[输入: algorithmName, sorter, data] --> B["initial = clone(data)"]
  B --> C["working = clone(initial)"]
  C --> D["state = clone(initial)"]
  D --> E[ops = new List<SortOperation>]
  E --> F["sorter.sort(working, listener)"]

  F --> G1["onCompare(i,j): ops += CompareOperation(i,j)"]
  F --> G2["onSwap(i,j): ops += SwapOperation(i,j); state 同步swap"]
  F --> G3["onSet(k,v): old=state[k]; ops += SetOperation(k,old,v); state[k]=v"]

  G1 --> H[排序完成]
  G2 --> H
  G3 --> H
  H --> I["输出 RecordedSort(algorithmName, initial, ops)"]
```

### 3.3 回放/撤销阶段内部流程（StepPlayer）

```mermaid
flowchart TD
  L["load(initial, operations)"] --> I["workingArray=clone(initial); cursor=0"]

  I --> N{用户: next?}
  N -->|是且hasNext| N1["op=operations[cursor]"]
  N1 --> N2["before = clone(workingArray)"]
  N2 --> N3["op.apply(workingArray)"]
  N3 --> N4[cursor++]
  N4 --> N5["返回: DescribedOperation(op,before)"]

  I --> P{用户: prev?}
  P -->|是且hasPrev| P1[cursor--]
  P1 --> P2["op=operations[cursor]"]
  P2 --> P3["before = clone(workingArray)"]
  P3 --> P4["op.undo(workingArray)"]
  P4 --> P5["返回: DescribedOperation(op,before)"]

  N -->|无下一步| X[返回null]
  P -->|无上一步| X
```

------

## 4. 回放控制状态机（PlaybackController）

```mermaid
stateDiagram-v2
  [*] --> Unloaded
  Unloaded --> Loaded: load(recorded)

  Loaded --> Playing: start()
  Playing --> Playing: tick(next) + emit(snapshot)
  Playing --> Paused: pause()
  Paused --> Playing: start()

  Playing --> Finished: tick到末尾(hasNext=false)
  Finished --> Loaded: load(recorded)

  Loaded --> Unloaded: stop()
  Playing --> Unloaded: stop()
  Paused --> Unloaded: stop()
  Finished --> Unloaded: stop()
```

"tick"由 JavaFX [PauseTransition](https://docs.oracle.com/javase/8/javafx/api/javafx/animation/PauseTransition.html)实现：每次到点执行一次 `next()`，若仍有下一步就重新 schedule。

------

## 5. 可视化刷新与回显/统计更新（UI线程）

### 5.1 高亮与完成态

- 

  回放每一步：

  - 

    [MainController.updateStepUi](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java#L340-L350)调用 [VisualizerPane.renderState](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/VisualizerPane.java#L80-L90)(state, op.index1, op.index2, highlightColor)

  - 

    高亮色由 [SortOperationType](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SortOperationType.java)映射：COMPARE 红 / SWAP 绿 / SET 蓝

- 

  回放到末尾：

  - 

    [MainController.onPlaybackFinished](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java#L352-L360)调用 [VisualizerPane.renderFinalState](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/view/VisualizerPane.java#L92-L100)(state, 绿色)

### 5.2 操作回显（"本步做了什么"）

- 

  [StepPlayer.next/prev](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/StepPlayer.java)会把"执行前数组快照"封装进 [DescribedOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/RecordedSort.java)

- 

  [MainController.updateStepUi](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java#L340-L350)调用 `op.description(null)`（参数会被忽略，实际使用"执行前快照"）

- 

  典型回显：

  - 

    [CompareOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/CompareOperation.java): 比较 a[i]=? 与 a[j]=?

  - 

    [SwapOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SwapOperation.java): 交换 a[i]=? 与 a[j]=?

  - 

    [SetOperation](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/step/SetOperation.java): 设置 a[k] old -> new

### 5.3 步骤统计（比较/交换/写回 当前/总）

- 

  录制完成后：[MainController.initOperationStats](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java#L280-L290)(operations) 生成 prefix 数组（长度 = steps+1）

- 

  回放每次更新：读取 `prefix[cursor]`与 `prefix[total]`

- 

  特殊：算法名为"猴子排序"时 `suppressStepStats=true`，统计栏显示 `-/-`，避免额外开销与体验问题

------

## 6. 性能比较（Benchmark）全过程

### 6.1 总流程图

```mermaid
flowchart TD
  A["用户点击"性能比较""] --> B[<strong>MainController.onBenchmark</strong>]
  B --> C["读取 size/dataType; setControlsDisabled(true)"]
  C --> D[算法列表 = <strong>AlgorithmRegistry.getAllAlgorithmNames</strong>]
  D --> E[过滤掉: 猴子/睡眠/珠排序]
  E --> F[<strong>BenchmarkService.createBenchmarkTask</strong>]
  F --> G[后台线程执行 Task]

  G --> H[生成 baseArray = <strong>DataGenerator</strong> 按dataType]
  H --> I{遍历每个 algoName}
  I --> J[<strong>Sorter</strong> sorter = <strong>AlgorithmRegistry.getSorter</strong>]
  J --> K[arrayCopy = baseArray.clone]
  K --> L["System.gc + sleep(100ms)"]
  L --> M[记录 startMem/startTime]
  M --> N["<strong>Sorter.sort</strong>(arrayCopy, null) 纯排序"]
  N --> O[记录 endTime/endMem]
  O --> P[计算 timeElapsed/memoryUsed]
  P --> Q["results.add(new PerformanceMetrics(...))"]
  Q --> I

  I -->|结束| R[UI线程 onSucceeded]
  R --> S[<strong>BenchmarkViewBuilder.buildResults</strong> -> TabPane]
  S --> T[rootPane.center = TabPane]
  T --> U["setControlsDisabled(false)"]
```

### 6.2 结果展示内容

- 

  摘要 Tab：数据类型、n、参与算法数；最快/最慢/平均/中位数；内存最小/最大。

- 

  时间对比/内存对比：BarChart；每个柱子安装 Tooltip 显示 `ms/MB`。

- 

  详细数据：TableView 展示算法名、耗时、平均复杂度、空间复杂度、稳定性。

------

## 7. "旧的实时回调动画"路径说明（当前代码中未被主流程使用）

仓库里仍保留了一个 [SortingService](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/SortingService.java)（实时执行 + listener 回调 UI）实现。

但在当前 [MainController](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/controller/MainController.java)的主流程中：

- 

  排序演示使用的是"录制→回放/撤销"路径（[StepRecordingService](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/StepRecordingService.java)+ [PlaybackController](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/playback/PlaybackController.java)），

- 

  [SortingService](https://tencent.yuanbao/src/main/java/org/example/sortingvisualizer/service/SortingService.java)没有被 new 或调用（搜索仅命中其自身定义与一处注释）。

保留它的价值更像"历史实现/备选实现"，但它天然难以支持可靠的"上一步"（不可逆）。