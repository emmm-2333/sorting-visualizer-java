# 1 问题描述

排序算法是数据结构与算法课程的核心内容之一。不同排序算法在不同数据规模与数据分布下具有不同的效率特征，仅从理论复杂度往往难以直观感受到“比较/交换/覆盖”等关键步骤对运行过程的影响。本课程设计实现一个桌面端“排序算法性能比较与动画演示系统”。

该系统需要实现以下功能：

1）使用数组存储待排序数据，支持生成数据、自定义输入及文件读取（如 .txt/.csv）

实现快速排序、归并排序、堆排序、计数排序、基数排序、桶排序等多种排序算法，并保证排序正确性

2）逐步展示排序过程中的关键操作（比较、交换/覆盖），通过动画演示帮助理解算法原理

3）对不同算法在不同数据集上进行性能对比，展示耗时、内存占用、稳定性、复杂度等指标

4）提供友好界面，支持算法选择、数据输入/选择、结果展示，并支持动画速度调节、暂停/继续等交互控制

5）最终系统将是一个可视化排序算法演示平台，能够直观展示算法执行过程，并支持性能比较分析。
2 需求分析

系统的基本功能：

1）数据准备：支持三种数据来源。

（a）生成数据：支持“随机数据 / 有序数据 / 逆序数据 / 部分有序”四种类型，数据量在界面输入框中给出（代码中生成时将数据量限制在 5~500）。

（b）自定义输入：在“自定义数据”文本框输入整数序列，支持空格/逗号/分号/制表符/换行等分隔符。

（c）文件读取：通过文件选择器加载 .txt/.csv 文件，读取内容后按同一解析规则转为数组。

2）动画排序：用户选择算法后点击“开始排序”，系统在后台线程执行排序，并在比较/交换/写回时更新界面柱状图；支持动画速度调节（滑块控制每一步的延迟），支持“暂停/继续”。

3）性能比较：点击“性能比较”后，对多种算法在同一数据集上进行基准测试（不启用动画回调），统计耗时与内存占用估算，并展示算法复杂度/稳定性元数据；程序会自动排除不适合做性能测试的演示型算法（猴子排序、睡眠排序、珠排序）。

输入形式：

1）生成数据：在界面输入“数据量”，选择“数据类型”，点击“生成数据”。

2）自定义输入：在“自定义数据”文本框输入一串整数（例如：3,1,4,1,5），点 击“显示数据”。

3）文件读取：点击“读取文件”，选择 .txt/.csv 文件。

输出形式：

1）动画演示输出：中间区域以柱状图形式显示数组，比较/交换/写回过程以高亮显示。 2）性能比较输出：显示三个页面：时间对比柱状图、内存对比柱状图（估算）、详细数据表（复杂度/稳定性等）。

测试数据要求：

1）生成数据：程序生成的数据为正整数序列（值域为 1~size）。

2）自定义/文件输入：需为可解析的整数序列；为了保证可视化柱状图显示效果，建议使用非负整数（输入负数可能导致柱高显示异常）。

# 3 概要设计

## 3.1 抽象数据类型

ADT  待排序数据（数组）

Data

以 `int[]` 表示待排序数据。

Operation

generateData

前置条件：用户已输入数据量、选择数据类型

输入：size、type

功能：生成随机/有序/逆序/部分有序数组

输出：int[]

后置条件：数组在界面中以柱状图显示

parseInputString

前置条件：用户已输入自定义字符串

输入：String input

功能：按多分隔符解析为整数数组

输出：int[]

后置条件：数组在界面中以柱状图显示

loadFromFile

前置条件：用户已选择文件

输入：File file

功能：读取文件内容并解析为整数数组

输出：int[]

后置条件：数组在界面中以柱状图显示

End ADT

ADT  排序步骤监听器（动画回调）

Data

无

Operation

onCompare

前置条件：排序正在进行

输入：index1, index2

功能：表示比较两个下标的元素

输出：无

后置条件：界面高亮比较位置

onSwap

前置条件：排序正在进行

输入：index1, index2

功能：表示交换两个下标的元素

输出：无

后置条件：界面更新数组并高亮交换位置

onSet

前置条件：排序正在进行

输入：index, value

功能：表示覆盖写回（赋值）操作

输出：无

后置条件：界面更新数组并高亮写回位置

End ADT

## 3.2 模块调用关系

应用入口层：SortingVisualizerApp：JavaFX应用程序入口，负责初始化应用窗口，加载主界面FXML文件并展示给用户。

控制层：MainController：主控制器，处理所有用户界面事件，协调各服务组件工作，管理界面状态更新。

服务层：SortingService：排序服务，负责创建和管理排序任务，在后台线程执行排序算法并控制动画演示。

BenchmarkService：性能基准测试服务，负责对各种排序算法进行性能测试并收集性能指标。

DataInputService：数据输入服务，负责解析用户输入的自定义数据字符串和从文件加载数据。

DataGenerator：数据生成器，负责生成各种类型的测试数据（随机、有序、逆序等）。

核心层

AlgorithmRegistry：算法注册表，使用工厂模式管理所有排序算法实例及其元数据，提供算法查找功能。

Sorter实现类：各种具体排序算法实现，如冒泡排序、快速排序、归并排序等，每种算法实现Sorter接口。

数据模型层：AlgorithmInfo：算法信息数据模型，存储算法的元数据，如名称、时间复杂度、空间复杂度等信息。

PerformanceMetrics：性能指标数据模型，用于封装和传递算法性能测试结果数据。

视图层：VisualizerPane：可视化面板，负责绘制排序过程的柱状图动画，实现SortStepListener接口以响应算法步骤更新。

SortStepListener：排序步骤监听器接口，使用观察者模式实现算法执行过程与UI更新的解耦。

模块调用关系如下：

![img](./%E6%80%BB%E6%8A%A5%E5%91%8A.assets/wps1.jpg)

图3.1 模块调用关系

## 3.3 主程序流程

![img](./%E6%80%BB%E6%8A%A5%E5%91%8A.assets/wps2.jpg)

图3.2 主程序流程图

应用初始化流程：系统启动时，首先执行SortingVisualizerApp主类，加载MainLayout.fxml界面文件。随后调用MainController.initialize方法初始化界面组件，包括下拉框、按钮、滑块等控件。系统接着通过DataGenerator生成初始测试数据，并调用VisualizerPane.setArray方法将数据以柱状图形式绘制在界面中。

用户交互处理流程：系统支持多种用户操作，主要包括：数据生成操作：用户点击"生成数据"按钮时，触发MainController.onGenerateData方法，根据用户选择的数据类型和规模，通过DataGenerator生成相应数据，并更新可视化面板。

自定义数据输入：用户可通过"显示数据"功能输入自定义数据，MainController.onShowData调用DataInputService.parseInputString解析输入，并更新可视化显示。

文件数据读取：用户可通过"读取文件"功能从外部文件加载数据，MainController.onLoadFile使用文件选择器选择文件，通过DataInputService.loadFromFile加载并解析数据。

排序执行：用户点击"开始排序"按钮触发MainController.onSort，SortingService.createSortTask从AlgorithmRegistry获取选定算法，在后台线程执行排序过程。排序算法通过SortStepListener接口回调通知VisualizerPane更新界面，实现可视化动画效果。

性能比较：用户点击"性能比较"按钮触发MainController.onBenchmark，BenchmarkService.createBenchmarkTask获取所有算法进行循环测试，通过无回调方式执行排序以获得准确性能数据，PerformanceMetrics收集性能指标并在图表中展示。

暂停/恢复功能：用户可通过"暂停"按钮控制排序过程的暂停与恢复，MainController.onPauseResume调用SortingService的暂停/恢复功能控制排序线程。
