# 项目结构与运行时序调用链（2025-12-29）

> 目标：把项目“按运行时序”串成一条调用链，说明每一步会进入哪些类/方法、数据如何流动、UI 如何更新。

---

## 1. 项目目录结构（从运行视角分层）

- `pom.xml`
  - Maven 构建与依赖：Java 17、JavaFX、插件配置。

- `src/main/java/org/example/sortingvisualizer/`（核心业务）
  - `SortingVisualizerApp.java`
    - JavaFX 应用入口：加载 FXML（`MainLayout.fxml`）与 CSS（`apple.css`），显示主窗口。

  - `controller/`
    - `MainController.java`
      - 主控制器（流程编排器）：响应 UI 按钮/滑块/快捷键；协调“数据准备 → 录制排序 → 回放控制 → UI 渲染 → 统计更新”；以及 Benchmark 的启动与结果展示。

  - `algorithm/`
    - `Sorter.java`
      - 排序算法统一接口：`sort(int[] array, SortStepListener listener)`。
    - `SortStepListener.java`
      - 算法步骤回调接口：`onCompare/onSwap/onSet`；用于“录制”排序过程。
    - `AlgorithmRegistry.java`
      - 算法注册中心：将“中文算法名”映射到 `Sorter` 实现与 `AlgorithmInfo` 元数据；供 UI 下拉框与 Benchmark 使用。
    - `impl/*.java`
      - 各排序算法实现：通过 `listener` 上报 compare/swap/set；核心逻辑在这里。

  - `service/`
    - `DataInputService.java`
      - 输入解析：自定义字符串解析为 `int[]`；文件读取并复用解析。
    - ==StepRecordingService.java==
      - 录制服务：把算法 `listener` 回调转换成可回放的 `SortOperation` 列表，输出 `RecordedSort`。
    - `BenchmarkService.java`
      - 性能比较：后台批量执行排序（不使用 listener，不做可视化），统计时间与内存，输出 `PerformanceMetrics` 列表。
    - `SortingService.java`
      - 旧版“实时回调动画”的服务路径（当前主流程以“录制→回放”为主）。

  - `step/`（可回放步骤模型）
    - `RecordedSort.java`
      - 一次录制结果：算法名 + 初始数组 + 不可变操作序列。
    - `SortOperation.java` / `SortOperationType.java`
      - 操作接口与类型枚举（COMPARE/SWAP/SET），支持 `apply/undo/description`。
    - `CompareOperation.java` / `SwapOperation.java` / `SetOperation.java`
      - 三类具体操作：比较/交换/写入（写入记录 old/new 以便撤销）。
    - `StepPlayer.java`
      - 步骤播放器：维护 `cursor`，提供 `next/prev`（apply/undo），并输出用于 UI 回显的描述。

  - `playback/`（回放控制器）
    - `PlaybackController.java`
      - 自动回放调度：封装 `StepPlayer`，提供 `start/pause/stop/next/prev`，并通过 `PlaybackSnapshot` 推送状态给 UI。
    - `PlaybackSnapshot.java`
      - 回放快照：`state/operation/cursor/size/hasPrev/hasNext/playing`。

  - `view/`
    - `VisualizerPane.java`
      - 绘制面板：根据数组状态绘制柱状图；根据操作类型高亮索引；完成态统一颜色。
    - `BenchmarkViewBuilder.java`
      - 基准测试视图构建：生成 TabPane（摘要/时间/内存/表格）。

  - `model/`
    - `AlgorithmInfo.java`：算法元数据（复杂度/稳定性等）。
    - `PerformanceMetrics.java`：单次基准测试结果（耗时/内存等）。

  - `util/`
    - `DataGenerator.java`：生成随机/有序/逆序/部分有序数据。

- `src/main/resources/org/example/sortingvisualizer/view/`
  - `MainLayout.fxml`：主界面布局与事件绑定（`onAction="#onSort"` 等）。
  - `apple.css`：UI 主题样式。

---

## 2. 运行时序：应用启动

1) `SortingVisualizerApp.start(Stage)`

- 加载 `MainLayout.fxml` → 自动创建 `MainController` 实例
- 绑定 `apple.css`
- `stage.show()` 展示窗口

1) `MainController.initialize()`（FXML 注入完成后自动调用）

- 创建 `VisualizerPane` 并 `rootPane.setCenter(visualizerPane)`
- 初始化下拉框：从 `AlgorithmRegistry.getAllAlgorithmNames()` 取算法列表
- 初始化数据类型选项
- 绑定速度滑块：`speedSlider` → `mapSpeedToDelay()` → `playbackController.setDelayMillis(delay)`
- 自动 `onGenerateData()`：启动即生成一组默认数据并绘制

---

## 3. 运行时序：数据准备（生成/自定义/文件）

### 3.1 点击“生成数据”

FXML：`MainLayout.fxml` 的 `generateButton onAction="#onGenerateData"`

调用链：

1) `MainController.onGenerateData()`

- 解析 `dataSizeField`（限制 5..500）
- 根据 `dataTypeComboBox` 调用 `DataGenerator.generate*()` 生成 `currentArray`
- `visualizerPane.setArray(currentArray)` → 触发绘制

### 3.2 点击“显示数据”（自定义输入）

FXML：`showDataButton onAction="#onShowData"`

调用链：

1) `MainController.onShowData()`

- `dataInputService.parseInputString(customDataField.getText())` → 得到 `currentArray`
- `visualizerPane.setArray(currentArray)`

### 3.3 点击“读取文件”

FXML：`loadFileButton onAction="#onLoadFile"`

调用链：

1) `MainController.onLoadFile()`

- `FileChooser` 选择文件
- `dataInputService.loadFromFile(file)` → 内部读取文本 → `parseInputString()` → `currentArray`
- `visualizerPane.setArray(currentArray)`

---

## 4. 运行时序：排序演示（录制 → 回放）

> 这条链路是项目的“核心主流程”。关键思路是：
>
> - 先在后台把排序过程“录制成操作序列”（可撤销）
> - 再用 `StepPlayer + PlaybackController` 对操作序列进行回放（支持上一步/下一步/暂停/继续）

### 4.1 点击“开始排序” → 进入录制阶段

FXML：`sortButton onAction="#onSort"`

调用链：

1) `MainController.onSort()`

- 前置校验：`currentArray != null`
- `arrayBeforeSort = currentArray.clone()`（用于“退出排序”恢复）
- 禁用大部分控件：`setControlsDisabled(true)`（避免并发改状态）
- 停止旧回放：`stopPlaybackIfNeeded()`
- 创建后台任务：`currentRecordTask = new Task<RecordedSort>() { call() { ... } }`

1) `currentRecordTask.call()`（后台线程执行）

- `AlgorithmRegistry.getSorter(algoName)` 获取 `Sorter`
- `stepRecordingService.record(algoName, sorter, currentArray)` 录制

1) `StepRecordingService.record(...)`

- `initial = data.clone()`
- `working = initial.clone()`（交给算法真实排序）
- `state = initial.clone()`（shadow：用于推导 Set 的 oldValue）
- 调用 `sorter.sort(working, listener)`
  - 算法内部在关键点调用 listener：
    - `onCompare(i,j)` → `ops.add(new CompareOperation(i,j))`
    - `onSwap(i,j)` → `ops.add(new SwapOperation(i,j))` + shadow state 同步交换
    - `onSet(i,val)` → old = state[i] → `ops.add(new SetOperation(i, old, val))` + shadow state 写入
- 返回 `new RecordedSort(algoName, initial, ops)`

### 4.2 录制完成 → 加载回放

触发点：`currentRecordTask.setOnSucceeded(...)`（JavaFX UI 线程）

调用链：

1) `MainController.onSort()` 的 `setOnSucceeded` 回调

- （可选）统计初始化：`initOperationStats(recorded.operations())` 生成 compare/swap/set 前缀数组
- 配置回放控制器：
  - `playbackController.setDelayMillis(delay)`
  - `playbackController.setOnUpdate(this::onPlaybackUpdate)`
  - `playbackController.setOnFinished(this::onPlaybackFinished)`
- `playbackController.load(recorded)`
  - 内部创建 `new StepPlayer(recorded.initialArray(), recorded.operations())`
  - `emit(null)` 发送初始快照
- UI 初始渲染：
  - `visualizerPane.setArray(recorded.initialArray())`
  - `updateStepUi(null)`（显示“准备开始”）
- `startPlayback()` → `playbackController.start()`（进入自动回放）

### 4.3 自动回放 tick：一步步推进并渲染

调用链：

1) `PlaybackController.start()`

- `playing=true` → `scheduleTick()`

1) `PlaybackController.scheduleTick()`

- `PauseTransition(Duration.millis(delayMillis))`
- 到点触发：
  - `op = player.next()`
  - `emit(op)`
  - 若还有下一步：递归 `scheduleTick()`
  - 否则：`playing=false`，调用 `onFinished.run()`

1) `StepPlayer.next()`

- `op = operations.get(cursor)`
- `before = workingArray.clone()`（用于 description）
- `op.apply(workingArray)`
- `cursor++`
- 返回 `new DescribedOperation(op, before)`（给 UI 用）

1) `PlaybackController.emit(op)` → `onUpdate.accept(new PlaybackSnapshot(...))`

2) `MainController.onPlaybackUpdate(snapshot)`

- `updateStepUi(snapshot.operation())`

1) `MainController.updateStepUi(op)`

- `state = playbackController.currentArray()`
- `visualizerPane.renderState(state, op.index1(), op.index2(), colorForOperation(op.type()))`
- `operationLabel.setText(op.description(null))`
- 更新按钮可用性与步骤数：
  - `stepLabel = cursor/size`
  - `prevStepButton = !hasPrev`，`nextStepButton = !hasNext`
- 更新统计：`updateStatsUi()`（用前缀数组按 cursor 取“当前/总”）

### 4.4 回放结束：渲染完成态

触发点：`PlaybackController` 在最后一步后调用 `onFinished`。

调用链：

1) `MainController.onPlaybackFinished()`

- `pausePlayback()`（确保不再 tick）
- `visualizerPane.renderFinalState(playbackController.currentArray(), 绿色)`
- 禁用 pause/exit，恢复控件：`setControlsDisabled(false)`
- `statusLabel = 排序完成`

---

## 5. 运行时序：手动控制（暂停/继续/上一步/下一步/退出排序）

### 5.1 点击“暂停/继续”

FXML：`pauseButton onAction="#onPauseResume"`

调用链：

- `MainController.onPauseResume()`
  - 若 `playbackController.isPlaying()`：`pausePlayback()` → `playbackController.pause()`（停止 timer 并 emit(null)）
  - 否则：`startPlayback()` → `playbackController.start()`（重新 scheduleTick）

### 5.2 点击“上一步”

FXML：`prevStepButton onAction="#onPrevStep"`

调用链：

- `MainController.onPrevStep()`
  - 先 `pausePlayback()`（保证不会与自动回放并发）
  - `playbackController.prev()`
    - `StepPlayer.prev()`：`cursor--` → `op.undo(workingArray)` → emit(op)
  - 更新 UI 同上：`onPlaybackUpdate → updateStepUi`

### 5.3 点击“下一步”

FXML：`nextStepButton onAction="#onNextStep"`

调用链：

- `MainController.onNextStep()`
  - `pausePlayback()`
  - `playbackController.next()` → `StepPlayer.next()` → `emit(op)` → `updateStepUi`

### 5.4 点击“退出排序”

FXML：`exitSortButton onAction="#onExitSort"`

调用链：

- `MainController.onExitSort()`
  - `stopPlaybackIfNeeded()`（清理回调 + 停止回放）
  - 若 `currentRecordTask` 正在跑：`cancel()`
  - 恢复数组：`currentArray = arrayBeforeSort.clone()`，并 `visualizerPane.setArray(currentArray)`
  - `setControlsDisabled(false)` + `resetStepUi()`

---

## 6. 运行时序：性能比较（Benchmark）

### 6.1 点击“性能比较” → 后台批量跑算法

FXML：`benchmarkButton onAction="#onBenchmark"`

调用链：

1) `MainController.onBenchmark()`

- 读取 `dataSizeField` 与 `dataTypeComboBox`
- 算法列表：`AlgorithmRegistry.getAllAlgorithmNames()`（过滤掉不适合对比的演示算法）
- `Task<List<PerformanceMetrics>> task = benchmarkService.createBenchmarkTask(size, type, algos)`
- `new Thread(task).start()`

1) `BenchmarkService.createBenchmarkTask().call()`（后台线程）

- `baseArray = generateData(size, type)`（调用 `DataGenerator.generate*()`）
- for each algo:
  - `sorter = AlgorithmRegistry.getSorter(algoName)`
  - `info = AlgorithmRegistry.getInfo(algoName)`
  - `arrayCopy = baseArray.clone()`（保证同一份输入、公平比较）
  - `System.gc()` + `Thread.sleep(100)`（尽量稳定内存测量）
  - 记录 `startMem/startTime`
  - `sorter.sort(arrayCopy, null)`（注意：listener=null，不录制、不回放、不绘制）
  - 记录 `endMem/endTime`，组装 `PerformanceMetrics` 加入结果

1) `benchmarkTask.setOnSucceeded`（UI 线程）

- `showBenchmarkResults(metrics, size, type)`
  - `rootPane.setCenter(benchmarkViewBuilder.buildResults(...))`
  - `BenchmarkViewBuilder` 构建 TabPane（摘要/时间柱状图/内存柱状图/表格）

---

## 7. 一句话总结“主流程调用链”

- 演示排序：`MainController.onSort → StepRecordingService.record → Sorter.sort(listener回调录制ops) → PlaybackController.load(start) → StepPlayer.next/prev → PlaybackSnapshot → MainController.updateStepUi → VisualizerPane.renderState/renderFinalState`
- 性能比较：`MainController.onBenchmark → BenchmarkService.createBenchmarkTask → Sorter.sort(null) → BenchmarkViewBuilder.buildResults → rootPane.center 切换为 TabPane`
