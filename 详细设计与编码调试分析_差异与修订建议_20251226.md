# 详细设计与编码调试分析（示例格式版）对齐现状：差异与修订建议（2025-12-26）

适用范围：本文件用于说明当前项目实现与 [详细设计与编码调试分析_中文版_示例格式版.md](详细设计与编码调试分析_中文版_示例格式版.md) 的不一致点，并给出“应该改成什么样”的可直接落地的改写建议（按原章节结构逐段对齐）。

---

## 0．结论（最重要的变化）

示例格式版 MD 的核心叙述建立在“SortingService 实时执行排序 + SortStepListener 回调驱动 UI 动画 + wait/notify 暂停”的架构上。

当前项目已演进为“先录制步骤，再回放/撤销”的架构：

- 录制：StepRecordingService 调用算法的 SortStepListener，把 compare/swap/set 录成 SortOperation 序列（RecordedSort）
- 回放：PlaybackController 封装 StepPlayer + JavaFX 定时器（PauseTransition），支持 start/pause/next/prev/stop
- UI：MainController 只做流程编排；VisualizerPane 负责绘制（含完成态统一绿色）

因此，示例 MD 里关于 SortingService 的“排序动画服务/暂停协议/退出排序”的描述已经不再代表当前主流程，需要整体替换为“录制-回放”体系。

---

## 1．第4章（详细设计）需要改的地方

### 1.1（4．详细设计）（1）数据类型：代码示例需要更新

示例 MD 当前示例字段：
- `Task<Void> currentSortTask`、`volatile boolean paused`：属于旧的 SortingService 实时动画模型

建议改为与当前 MainController 一致的字段示例（建议替换原代码块）：

```java
private int[] currentArray;
private long delay = 50;

// 录制任务：后台线程生成可回放步骤
private Task<RecordedSort> currentRecordTask;

// 回放控制：封装 next/prev/start/pause/stop + 定时逻辑
private final PlaybackController playbackController = new PlaybackController();

// 退出排序恢复
private int[] arrayBeforeSort;

// 统计前缀（当前/总）
private int[] comparePrefix;
private int[] swapPrefix;
private int[] setPrefix;
```

同时建议在“并发与 JavaFX 相关类型”补充以下当前项目新增/核心类型：
- `RecordedSort`：录制输出（initialArray + operations）
- `SortOperation` / `SortOperationType`：单步操作抽象（compare/swap/set）
- `StepPlayer`：apply/undo + cursor
- `PlaybackController` / `PlaybackSnapshot`：回放控制与 UI 更新快照
- `BenchmarkViewBuilder`：benchmark 结果视图构建（TabPane/Chart/Table + Tooltip）

### 1.2（4．详细设计）（2）主要模块算法描述：SortingService 章节需要整体替换

示例 MD 当前选择了 3 个核心模块，其中“② 排序动画服务（SortingService）”已不再是当前主流程。

建议将“②”替换为：

#### ② 排序步骤录制与回放（StepRecordingService + StepPlayer + PlaybackController）

**功能**：
- 录制阶段：在后台线程执行 `Sorter.sort`，但不直接更新 UI，而是把每个关键步骤记录为可撤销的 `SortOperation` 序列
- 回放阶段：在 UI 线程中按定时器逐步 apply/undo，并在界面上支持“上一步/下一步/暂停/继续”

**为什么需要这样设计**：
- 旧模型（实时回调）天然只能“向前”，无法可靠实现“上一步”
- 新模型把排序过程离散为可逆操作，才可以稳定实现 prev/next

**推荐流程图（可直接替换示例 MD 的图2/图3）**：

图2（新）：录制流程

```mermaid
flowchart TD
  A[用户点击开始排序] --> B[MainController 创建 Task<RecordedSort>]
  B --> C[后台线程: StepRecordingService.record]
  C --> D[AlgorithmRegistry.getSorter]
  D --> E[working = data.clone]
  E --> F[sorter.sort(working, listener)]
  F --> G[listener: 生成 SortOperation 列表 operations]
  G --> H[返回 RecordedSort(initialArray, operations)]
  H --> I[UI线程 onSucceeded: PlaybackController.load]
```

图3（新）：回放流程（支持 next/prev/pause）

```mermaid
flowchart TD
  A[PlaybackController.load] --> B[StepPlayer(cursor=0)]
  B --> C[emit snapshot: 准备开始]
  C --> D{playing?}
  D -->|start| E[PauseTransition 定时 tick]
  E --> F[StepPlayer.next: apply + cursor++]
  F --> G[emit snapshot: operation + array]
  G --> H{hasNext?}
  H -->|是| E
  H -->|否| I[onFinished: 停止并渲染完成态]

  J[用户点击上一步] --> K[StepPlayer.prev: undo + cursor--]
  K --> G

  L[用户点击暂停] --> M[playing=false; stop timer]
```

**完成态渲染**：
- 当 `cursor == size` 时，VisualizerPane 会把所有柱子统一渲染为绿色，避免停留在最后一步的高亮色。

> 备注：SortingService 仍存在于代码中，但当前 MainController 的排序展示流程不依赖它。若文档仍要介绍 SortingService，可把它降级为“历史实现/备用实现”，避免与主流程混淆。

### 1.3（4．详细设计）（3）其它模块：MainController、VisualizerPane 段落需要补充新交互

示例 MD 的 MainController 概述仍写的是 `SortingService.createSortTask`。

建议改为：
- 排序动画：读取算法名 → 创建 `Task<RecordedSort>`（录制）→ `PlaybackController.load`（回放）
- 操作回显：通过 `SortOperation.description(...)` 展示“本步做了什么”
- 上一步/下一步：调用 `playbackController.prev()` / `playbackController.next()`
- 快捷键：←/→ 单步，Space 暂停/继续（如文档需要可补充）

VisualizerPane 的描述建议补充：
- 柱子颜色按数值映射，避免“全黑”
- 支持最大柱宽与居中
- 支持完成态统一绿色（renderFinalState）

---

## 2．第5章（编码与调试分析）需要改的地方

示例 MD 的问题 1/2 强绑定旧的 SortingService 暂停协议（wait/notify）。当前主流程已变为录制-回放，因此建议把“遇到的问题”换成更贴合现状的 3~5 条。

下面是推荐替换稿（可直接覆盖原【问题一~五】）：

### 【问题一】无法可靠支持“上一步”

**现象**：实时回调模式只能前进，无法撤销已经执行的排序操作。

**解决办法**：引入“录制-回放”体系，把 compare/swap/set 抽象为可 `apply/undo` 的 SortOperation，回放时通过 StepPlayer 管理 cursor。

### 【问题二】猴子排序（BogoSort）在数据量稍大时导致程序异常

**现象**：n 稍大时步骤数呈阶乘爆炸，录制会造成内存/时间不可控。

**解决办法**：对猴子排序加入硬保护：当 n > 9 阻止执行并提示用户调整规模。

### 【问题三】回放初始化阶段统计越界（ArrayIndexOutOfBoundsException）

**现象**：回放 load 时可能触发 UI 更新，若统计前缀数组仍是上一轮长度，会在统计显示处越界。

**解决办法**：
- stop 时先清理回调，避免旧回调被 load/pause 过程触发
- 初始化顺序调整：先建统计前缀，再 set 回调，再 load
- 统计显示增加 clamp 防守，避免 UI 崩溃

### 【问题四】性能比较展示不够直观

**解决办法**：benchmark 结果视图抽离为独立 Builder，并为图表柱子增加 Tooltip（耗时 ms/内存 MB），提升可读性。

---

## 3．第6章（使用说明）需要改的地方

### 3.1 默认参数与输入说明

- “数据规模”默认值：建议更新为 20（当前 UI 默认是 20）。
- 上限/下限仍为：上限 500，下限 5（输入不合法会回退并重置输入框）。

### 3.2 新增/变更的按钮与交互（示例 MD 目前未覆盖）

建议在“开始排序动画”与“暂停与继续”之间插入一段：

- 上一步/下一步：用于逐步回放已录制的排序操作，并在“当前操作回显”区域显示本步做了什么
- 步骤统计：比较/交换/写入的“当前/总次数”
- 排序完成：柱子统一绿色，表示完成态

如需写入快捷键说明（可选）：
- ←：上一步
- →：下一步
- Space：暂停/继续

### 3.3 性能比较页面说明补充

建议补充：
- 图表柱子支持悬停 Tooltip（显示 ms 与 MB）

---

## 4．建议的最小改写策略（不重写全文，最快对齐）

如果你希望“尽量少改动，但保证内容正确”，推荐按以下最小集合改：

1) 删除/降级示例 MD 中“② SortingService：回调驱动 + wait/notify 暂停协议”的主流程描述
2) 新增“② 步骤录制与回放（StepRecordingService + PlaybackController）”并给出两张流程图
3) 更新“数据类型”代码示例字段（从 currentSortTask/paused → currentRecordTask/playbackController/前缀统计）
4) 更新“编码与调试分析”的问题列表，使其覆盖：上一步方案、猴子排序保护、回放统计越界修复、benchmark tooltip
5) 在“使用说明”补充：上一步/下一步/操作回显/统计/完成态全绿，以及数据规模默认值 20
